/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export declare namespace IHederaTokenService {
  export type KeyValueStruct = {
    inheritAccountKey: boolean;
    contractId: AddressLike;
    ed25519: BytesLike;
    ECDSA_secp256k1: BytesLike;
    delegatableContractId: AddressLike;
  };

  export type KeyValueStructOutput = [
    inheritAccountKey: boolean,
    contractId: string,
    ed25519: string,
    ECDSA_secp256k1: string,
    delegatableContractId: string
  ] & {
    inheritAccountKey: boolean;
    contractId: string;
    ed25519: string;
    ECDSA_secp256k1: string;
    delegatableContractId: string;
  };

  export type TokenKeyStruct = {
    keyType: BigNumberish;
    key: IHederaTokenService.KeyValueStruct;
  };

  export type TokenKeyStructOutput = [
    keyType: bigint,
    key: IHederaTokenService.KeyValueStructOutput
  ] & { keyType: bigint; key: IHederaTokenService.KeyValueStructOutput };

  export type ExpiryStruct = {
    second: BigNumberish;
    autoRenewAccount: AddressLike;
    autoRenewPeriod: BigNumberish;
  };

  export type ExpiryStructOutput = [
    second: bigint,
    autoRenewAccount: string,
    autoRenewPeriod: bigint
  ] & { second: bigint; autoRenewAccount: string; autoRenewPeriod: bigint };

  export type HederaTokenStruct = {
    name: string;
    symbol: string;
    treasury: AddressLike;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: BigNumberish;
    freezeDefault: boolean;
    tokenKeys: IHederaTokenService.TokenKeyStruct[];
    expiry: IHederaTokenService.ExpiryStruct;
  };

  export type HederaTokenStructOutput = [
    name: string,
    symbol: string,
    treasury: string,
    memo: string,
    tokenSupplyType: boolean,
    maxSupply: bigint,
    freezeDefault: boolean,
    tokenKeys: IHederaTokenService.TokenKeyStructOutput[],
    expiry: IHederaTokenService.ExpiryStructOutput
  ] & {
    name: string;
    symbol: string;
    treasury: string;
    memo: string;
    tokenSupplyType: boolean;
    maxSupply: bigint;
    freezeDefault: boolean;
    tokenKeys: IHederaTokenService.TokenKeyStructOutput[];
    expiry: IHederaTokenService.ExpiryStructOutput;
  };

  export type FixedFeeStruct = {
    amount: BigNumberish;
    tokenId: AddressLike;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: AddressLike;
  };

  export type FixedFeeStructOutput = [
    amount: bigint,
    tokenId: string,
    useHbarsForPayment: boolean,
    useCurrentTokenForPayment: boolean,
    feeCollector: string
  ] & {
    amount: bigint;
    tokenId: string;
    useHbarsForPayment: boolean;
    useCurrentTokenForPayment: boolean;
    feeCollector: string;
  };

  export type FractionalFeeStruct = {
    numerator: BigNumberish;
    denominator: BigNumberish;
    minimumAmount: BigNumberish;
    maximumAmount: BigNumberish;
    netOfTransfers: boolean;
    feeCollector: AddressLike;
  };

  export type FractionalFeeStructOutput = [
    numerator: bigint,
    denominator: bigint,
    minimumAmount: bigint,
    maximumAmount: bigint,
    netOfTransfers: boolean,
    feeCollector: string
  ] & {
    numerator: bigint;
    denominator: bigint;
    minimumAmount: bigint;
    maximumAmount: bigint;
    netOfTransfers: boolean;
    feeCollector: string;
  };

  export type RoyaltyFeeStruct = {
    numerator: BigNumberish;
    denominator: BigNumberish;
    amount: BigNumberish;
    tokenId: AddressLike;
    useHbarsForPayment: boolean;
    feeCollector: AddressLike;
  };

  export type RoyaltyFeeStructOutput = [
    numerator: bigint,
    denominator: bigint,
    amount: bigint,
    tokenId: string,
    useHbarsForPayment: boolean,
    feeCollector: string
  ] & {
    numerator: bigint;
    denominator: bigint;
    amount: bigint;
    tokenId: string;
    useHbarsForPayment: boolean;
    feeCollector: string;
  };

  export type AccountAmountStruct = {
    accountID: AddressLike;
    amount: BigNumberish;
    isApproval: boolean;
  };

  export type AccountAmountStructOutput = [
    accountID: string,
    amount: bigint,
    isApproval: boolean
  ] & { accountID: string; amount: bigint; isApproval: boolean };

  export type TransferListStruct = {
    transfers: IHederaTokenService.AccountAmountStruct[];
  };

  export type TransferListStructOutput = [
    transfers: IHederaTokenService.AccountAmountStructOutput[]
  ] & { transfers: IHederaTokenService.AccountAmountStructOutput[] };

  export type NftTransferStruct = {
    senderAccountID: AddressLike;
    receiverAccountID: AddressLike;
    serialNumber: BigNumberish;
    isApproval: boolean;
  };

  export type NftTransferStructOutput = [
    senderAccountID: string,
    receiverAccountID: string,
    serialNumber: bigint,
    isApproval: boolean
  ] & {
    senderAccountID: string;
    receiverAccountID: string;
    serialNumber: bigint;
    isApproval: boolean;
  };

  export type TokenTransferListStruct = {
    token: AddressLike;
    transfers: IHederaTokenService.AccountAmountStruct[];
    nftTransfers: IHederaTokenService.NftTransferStruct[];
  };

  export type TokenTransferListStructOutput = [
    token: string,
    transfers: IHederaTokenService.AccountAmountStructOutput[],
    nftTransfers: IHederaTokenService.NftTransferStructOutput[]
  ] & {
    token: string;
    transfers: IHederaTokenService.AccountAmountStructOutput[];
    nftTransfers: IHederaTokenService.NftTransferStructOutput[];
  };

  export type TokenInfoStruct = {
    token: IHederaTokenService.HederaTokenStruct;
    totalSupply: BigNumberish;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStruct[];
    fractionalFees: IHederaTokenService.FractionalFeeStruct[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStruct[];
    ledgerId: string;
  };

  export type TokenInfoStructOutput = [
    token: IHederaTokenService.HederaTokenStructOutput,
    totalSupply: bigint,
    deleted: boolean,
    defaultKycStatus: boolean,
    pauseStatus: boolean,
    fixedFees: IHederaTokenService.FixedFeeStructOutput[],
    fractionalFees: IHederaTokenService.FractionalFeeStructOutput[],
    royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[],
    ledgerId: string
  ] & {
    token: IHederaTokenService.HederaTokenStructOutput;
    totalSupply: bigint;
    deleted: boolean;
    defaultKycStatus: boolean;
    pauseStatus: boolean;
    fixedFees: IHederaTokenService.FixedFeeStructOutput[];
    fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
    royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
    ledgerId: string;
  };

  export type FungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    decimals: BigNumberish;
  };

  export type FungibleTokenInfoStructOutput = [
    tokenInfo: IHederaTokenService.TokenInfoStructOutput,
    decimals: bigint
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    decimals: bigint;
  };

  export type NonFungibleTokenInfoStruct = {
    tokenInfo: IHederaTokenService.TokenInfoStruct;
    serialNumber: BigNumberish;
    ownerId: AddressLike;
    creationTime: BigNumberish;
    metadata: BytesLike;
    spenderId: AddressLike;
  };

  export type NonFungibleTokenInfoStructOutput = [
    tokenInfo: IHederaTokenService.TokenInfoStructOutput,
    serialNumber: bigint,
    ownerId: string,
    creationTime: bigint,
    metadata: string,
    spenderId: string
  ] & {
    tokenInfo: IHederaTokenService.TokenInfoStructOutput;
    serialNumber: bigint;
    ownerId: string;
    creationTime: bigint;
    metadata: string;
    spenderId: string;
  };
}

export interface IHederaTokenServiceInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "approveNFT"
      | "associateToken"
      | "associateTokens"
      | "burnToken"
      | "createFungibleToken"
      | "createFungibleTokenWithCustomFees"
      | "createNonFungibleToken"
      | "createNonFungibleTokenWithCustomFees"
      | "cryptoTransfer"
      | "deleteToken"
      | "dissociateToken"
      | "dissociateTokens"
      | "freezeToken"
      | "getApproved"
      | "getFungibleTokenInfo"
      | "getNonFungibleTokenInfo"
      | "getTokenCustomFees"
      | "getTokenDefaultFreezeStatus"
      | "getTokenDefaultKycStatus"
      | "getTokenExpiryInfo"
      | "getTokenInfo"
      | "getTokenKey"
      | "getTokenType"
      | "grantTokenKyc"
      | "isApprovedForAll"
      | "isFrozen"
      | "isKyc"
      | "isToken"
      | "mintToken"
      | "pauseToken"
      | "redirectForToken"
      | "revokeTokenKyc"
      | "setApprovalForAll"
      | "transferFrom"
      | "transferFromNFT"
      | "transferNFT"
      | "transferNFTs"
      | "transferToken"
      | "transferTokens"
      | "unfreezeToken"
      | "unpauseToken"
      | "updateTokenExpiryInfo"
      | "updateTokenInfo"
      | "updateTokenKeys"
      | "wipeTokenAccount"
      | "wipeTokenAccountNFT"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveNFT",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "associateToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "associateTokens",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "burnToken",
    values: [AddressLike, BigNumberish, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      BigNumberish,
      BigNumberish,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.FractionalFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleToken",
    values: [IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    values: [
      IHederaTokenService.HederaTokenStruct,
      IHederaTokenService.FixedFeeStruct[],
      IHederaTokenService.RoyaltyFeeStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cryptoTransfer",
    values: [
      IHederaTokenService.TransferListStruct,
      IHederaTokenService.TokenTransferListStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "dissociateTokens",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproved",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFungibleTokenInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonFungibleTokenInfo",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenCustomFees",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultFreezeStatus",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenDefaultKycStatus",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenExpiryInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenKey",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenType",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "grantTokenKyc",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isApprovedForAll",
    values: [AddressLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isFrozen",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isKyc",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mintToken",
    values: [AddressLike, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "pauseToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "redirectForToken",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeTokenKyc",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setApprovalForAll",
    values: [AddressLike, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromNFT",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFT",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferNFTs",
    values: [AddressLike, AddressLike[], AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToken",
    values: [AddressLike, AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferTokens",
    values: [AddressLike, AddressLike[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseToken",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenExpiryInfo",
    values: [AddressLike, IHederaTokenService.ExpiryStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenInfo",
    values: [AddressLike, IHederaTokenService.HederaTokenStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokenKeys",
    values: [AddressLike, IHederaTokenService.TokenKeyStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccount",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "wipeTokenAccountNFT",
    values: [AddressLike, AddressLike, BigNumberish[]]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approveNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "associateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "associateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burnToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createNonFungibleTokenWithCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cryptoTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dissociateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonFungibleTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenCustomFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultFreezeStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenDefaultKycStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenKey",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "grantTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isApprovedForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isFrozen", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isKyc", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pauseToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redirectForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revokeTokenKyc",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setApprovalForAll",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenExpiryInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokenKeys",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "wipeTokenAccountNFT",
    data: BytesLike
  ): Result;
}

export interface IHederaTokenService extends BaseContract {
  connect(runner?: ContractRunner | null): IHederaTokenService;
  waitForDeployment(): Promise<this>;

  interface: IHederaTokenServiceInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [token: AddressLike, owner: AddressLike, spender: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; allowance: bigint }],
    "nonpayable"
  >;

  approve: TypedContractMethod<
    [token: AddressLike, spender: AddressLike, amount: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  approveNFT: TypedContractMethod<
    [token: AddressLike, approved: AddressLike, serialNumber: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  associateToken: TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  associateTokens: TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;

  burnToken: TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, serialNumbers: BigNumberish[]],
    [[bigint, bigint] & { responseCode: bigint; newTotalSupply: bigint }],
    "nonpayable"
  >;

  createFungibleToken: TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;

  createFungibleTokenWithCustomFees: TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[]
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;

  createNonFungibleToken: TypedContractMethod<
    [token: IHederaTokenService.HederaTokenStruct],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;

  createNonFungibleTokenWithCustomFees: TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;

  cryptoTransfer: TypedContractMethod<
    [
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[]
    ],
    [bigint],
    "nonpayable"
  >;

  deleteToken: TypedContractMethod<
    [token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  dissociateToken: TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  dissociateTokens: TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;

  freezeToken: TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;

  getApproved: TypedContractMethod<
    [token: AddressLike, serialNumber: BigNumberish],
    [[bigint, string] & { responseCode: bigint; approved: string }],
    "nonpayable"
  >;

  getFungibleTokenInfo: TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, IHederaTokenService.FungibleTokenInfoStructOutput] & {
        responseCode: bigint;
        fungibleTokenInfo: IHederaTokenService.FungibleTokenInfoStructOutput;
      }
    ],
    "nonpayable"
  >;

  getNonFungibleTokenInfo: TypedContractMethod<
    [token: AddressLike, serialNumber: BigNumberish],
    [
      [bigint, IHederaTokenService.NonFungibleTokenInfoStructOutput] & {
        responseCode: bigint;
        nonFungibleTokenInfo: IHederaTokenService.NonFungibleTokenInfoStructOutput;
      }
    ],
    "nonpayable"
  >;

  getTokenCustomFees: TypedContractMethod<
    [token: AddressLike],
    [
      [
        bigint,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ] & {
        responseCode: bigint;
        fixedFees: IHederaTokenService.FixedFeeStructOutput[];
        fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
        royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
      }
    ],
    "nonpayable"
  >;

  getTokenDefaultFreezeStatus: TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, boolean] & { responseCode: bigint; defaultFreezeStatus: boolean }
    ],
    "nonpayable"
  >;

  getTokenDefaultKycStatus: TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; defaultKycStatus: boolean }],
    "nonpayable"
  >;

  getTokenExpiryInfo: TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, IHederaTokenService.ExpiryStructOutput] & {
        responseCode: bigint;
        expiry: IHederaTokenService.ExpiryStructOutput;
      }
    ],
    "nonpayable"
  >;

  getTokenInfo: TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, IHederaTokenService.TokenInfoStructOutput] & {
        responseCode: bigint;
        tokenInfo: IHederaTokenService.TokenInfoStructOutput;
      }
    ],
    "nonpayable"
  >;

  getTokenKey: TypedContractMethod<
    [token: AddressLike, keyType: BigNumberish],
    [
      [bigint, IHederaTokenService.KeyValueStructOutput] & {
        responseCode: bigint;
        key: IHederaTokenService.KeyValueStructOutput;
      }
    ],
    "nonpayable"
  >;

  getTokenType: TypedContractMethod<
    [token: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; tokenType: bigint }],
    "nonpayable"
  >;

  grantTokenKyc: TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;

  isApprovedForAll: TypedContractMethod<
    [token: AddressLike, owner: AddressLike, operator: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; approved: boolean }],
    "nonpayable"
  >;

  isFrozen: TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; frozen: boolean }],
    "nonpayable"
  >;

  isKyc: TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; kycGranted: boolean }],
    "nonpayable"
  >;

  isToken: TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; isToken: boolean }],
    "nonpayable"
  >;

  mintToken: TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, metadata: BytesLike[]],
    [
      [bigint, bigint, bigint[]] & {
        responseCode: bigint;
        newTotalSupply: bigint;
        serialNumbers: bigint[];
      }
    ],
    "nonpayable"
  >;

  pauseToken: TypedContractMethod<[token: AddressLike], [bigint], "nonpayable">;

  redirectForToken: TypedContractMethod<
    [token: AddressLike, encodedFunctionSelector: BytesLike],
    [[bigint, string] & { responseCode: bigint; response: string }],
    "nonpayable"
  >;

  revokeTokenKyc: TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;

  setApprovalForAll: TypedContractMethod<
    [token: AddressLike, operator: AddressLike, approved: boolean],
    [bigint],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [
      token: AddressLike,
      from: AddressLike,
      to: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferFromNFT: TypedContractMethod<
    [
      token: AddressLike,
      from: AddressLike,
      to: AddressLike,
      serialNumber: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferNFT: TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      serialNumber: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferNFTs: TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike[],
      receiver: AddressLike[],
      serialNumber: BigNumberish[]
    ],
    [bigint],
    "nonpayable"
  >;

  transferToken: TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  transferTokens: TypedContractMethod<
    [token: AddressLike, accountId: AddressLike[], amount: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  unfreezeToken: TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;

  unpauseToken: TypedContractMethod<
    [token: AddressLike],
    [bigint],
    "nonpayable"
  >;

  updateTokenExpiryInfo: TypedContractMethod<
    [token: AddressLike, expiryInfo: IHederaTokenService.ExpiryStruct],
    [bigint],
    "nonpayable"
  >;

  updateTokenInfo: TypedContractMethod<
    [token: AddressLike, tokenInfo: IHederaTokenService.HederaTokenStruct],
    [bigint],
    "nonpayable"
  >;

  updateTokenKeys: TypedContractMethod<
    [token: AddressLike, keys: IHederaTokenService.TokenKeyStruct[]],
    [bigint],
    "nonpayable"
  >;

  wipeTokenAccount: TypedContractMethod<
    [token: AddressLike, account: AddressLike, amount: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  wipeTokenAccountNFT: TypedContractMethod<
    [token: AddressLike, account: AddressLike, serialNumbers: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [token: AddressLike, owner: AddressLike, spender: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; allowance: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [token: AddressLike, spender: AddressLike, amount: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveNFT"
  ): TypedContractMethod<
    [token: AddressLike, approved: AddressLike, serialNumber: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "associateToken"
  ): TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "associateTokens"
  ): TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "burnToken"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, serialNumbers: BigNumberish[]],
    [[bigint, bigint] & { responseCode: bigint; newTotalSupply: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createFungibleToken"
  ): TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createFungibleTokenWithCustomFees"
  ): TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      initialTotalSupply: BigNumberish,
      decimals: BigNumberish,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      fractionalFees: IHederaTokenService.FractionalFeeStruct[]
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createNonFungibleToken"
  ): TypedContractMethod<
    [token: IHederaTokenService.HederaTokenStruct],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createNonFungibleTokenWithCustomFees"
  ): TypedContractMethod<
    [
      token: IHederaTokenService.HederaTokenStruct,
      fixedFees: IHederaTokenService.FixedFeeStruct[],
      royaltyFees: IHederaTokenService.RoyaltyFeeStruct[]
    ],
    [[bigint, string] & { responseCode: bigint; tokenAddress: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "cryptoTransfer"
  ): TypedContractMethod<
    [
      transferList: IHederaTokenService.TransferListStruct,
      tokenTransfers: IHederaTokenService.TokenTransferListStruct[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "deleteToken"
  ): TypedContractMethod<[token: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "dissociateToken"
  ): TypedContractMethod<
    [account: AddressLike, token: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "dissociateTokens"
  ): TypedContractMethod<
    [account: AddressLike, tokens: AddressLike[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "freezeToken"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getApproved"
  ): TypedContractMethod<
    [token: AddressLike, serialNumber: BigNumberish],
    [[bigint, string] & { responseCode: bigint; approved: string }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getFungibleTokenInfo"
  ): TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, IHederaTokenService.FungibleTokenInfoStructOutput] & {
        responseCode: bigint;
        fungibleTokenInfo: IHederaTokenService.FungibleTokenInfoStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getNonFungibleTokenInfo"
  ): TypedContractMethod<
    [token: AddressLike, serialNumber: BigNumberish],
    [
      [bigint, IHederaTokenService.NonFungibleTokenInfoStructOutput] & {
        responseCode: bigint;
        nonFungibleTokenInfo: IHederaTokenService.NonFungibleTokenInfoStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenCustomFees"
  ): TypedContractMethod<
    [token: AddressLike],
    [
      [
        bigint,
        IHederaTokenService.FixedFeeStructOutput[],
        IHederaTokenService.FractionalFeeStructOutput[],
        IHederaTokenService.RoyaltyFeeStructOutput[]
      ] & {
        responseCode: bigint;
        fixedFees: IHederaTokenService.FixedFeeStructOutput[];
        fractionalFees: IHederaTokenService.FractionalFeeStructOutput[];
        royaltyFees: IHederaTokenService.RoyaltyFeeStructOutput[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenDefaultFreezeStatus"
  ): TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, boolean] & { responseCode: bigint; defaultFreezeStatus: boolean }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenDefaultKycStatus"
  ): TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; defaultKycStatus: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenExpiryInfo"
  ): TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, IHederaTokenService.ExpiryStructOutput] & {
        responseCode: bigint;
        expiry: IHederaTokenService.ExpiryStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenInfo"
  ): TypedContractMethod<
    [token: AddressLike],
    [
      [bigint, IHederaTokenService.TokenInfoStructOutput] & {
        responseCode: bigint;
        tokenInfo: IHederaTokenService.TokenInfoStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenKey"
  ): TypedContractMethod<
    [token: AddressLike, keyType: BigNumberish],
    [
      [bigint, IHederaTokenService.KeyValueStructOutput] & {
        responseCode: bigint;
        key: IHederaTokenService.KeyValueStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getTokenType"
  ): TypedContractMethod<
    [token: AddressLike],
    [[bigint, bigint] & { responseCode: bigint; tokenType: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "grantTokenKyc"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isApprovedForAll"
  ): TypedContractMethod<
    [token: AddressLike, owner: AddressLike, operator: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; approved: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isFrozen"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; frozen: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isKyc"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; kycGranted: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isToken"
  ): TypedContractMethod<
    [token: AddressLike],
    [[bigint, boolean] & { responseCode: bigint; isToken: boolean }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mintToken"
  ): TypedContractMethod<
    [token: AddressLike, amount: BigNumberish, metadata: BytesLike[]],
    [
      [bigint, bigint, bigint[]] & {
        responseCode: bigint;
        newTotalSupply: bigint;
        serialNumbers: bigint[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "pauseToken"
  ): TypedContractMethod<[token: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "redirectForToken"
  ): TypedContractMethod<
    [token: AddressLike, encodedFunctionSelector: BytesLike],
    [[bigint, string] & { responseCode: bigint; response: string }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "revokeTokenKyc"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setApprovalForAll"
  ): TypedContractMethod<
    [token: AddressLike, operator: AddressLike, approved: boolean],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [
      token: AddressLike,
      from: AddressLike,
      to: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFromNFT"
  ): TypedContractMethod<
    [
      token: AddressLike,
      from: AddressLike,
      to: AddressLike,
      serialNumber: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferNFT"
  ): TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      serialNumber: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferNFTs"
  ): TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike[],
      receiver: AddressLike[],
      serialNumber: BigNumberish[]
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferToken"
  ): TypedContractMethod<
    [
      token: AddressLike,
      sender: AddressLike,
      recipient: AddressLike,
      amount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferTokens"
  ): TypedContractMethod<
    [token: AddressLike, accountId: AddressLike[], amount: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unfreezeToken"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "unpauseToken"
  ): TypedContractMethod<[token: AddressLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "updateTokenExpiryInfo"
  ): TypedContractMethod<
    [token: AddressLike, expiryInfo: IHederaTokenService.ExpiryStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenInfo"
  ): TypedContractMethod<
    [token: AddressLike, tokenInfo: IHederaTokenService.HederaTokenStruct],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateTokenKeys"
  ): TypedContractMethod<
    [token: AddressLike, keys: IHederaTokenService.TokenKeyStruct[]],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "wipeTokenAccount"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike, amount: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "wipeTokenAccountNFT"
  ): TypedContractMethod<
    [token: AddressLike, account: AddressLike, serialNumbers: BigNumberish[]],
    [bigint],
    "nonpayable"
  >;

  filters: {};
}
